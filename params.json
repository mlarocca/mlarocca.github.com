{"name":"Mlarocca.github.com","tagline":"MLR Blog","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-37178706-1","body":"## ** Combining effective encapsulation and inheritance in JavaScript**\r\n\r\nWhile developing a plugin for the D3 graphic library, I found myself facing one of the most common conundrum for a JavaScript programmer: how on Earth is it possible to get a good compromise between encapsulation and extensibility?\r\n\r\nDon't get me wrong, there are many different known techniques to safely and effectively keep private attributes and methods really private (mostly involving closure and local vars), as well as there are many more to mimic inheritance, from pseudo-classical to prototypal or parasitic ones.\r\nA very good source of inspiration for all of these techniques can be found on _Douglas Crockford_ web sites or, if you have a little bit more time, in some of his great videos on _YUITheather_ (a must for any JS developer).\r\n\r\nBut as far as I know there have been only a few attempts to cope with both problems at the same time: there is no \"protected\" encapsulation in JavaScript, and none of them looks particularly easy or satisfying to me.\r\nAnd that's a bummer, I mean, web development today is all about mash-ups, and every JS engineer  at some point will have to exploit mash-ups, so she will be (well, at least he really SHOULD BE) necessarily concerned about the methods that his objects are going to expose to consumers.\r\n\r\nThe most common solution starts, or at least it should, from embracing an Object Capability System.\r\nIn such a paradigm, Objects can communicate with other objects only if they have a reference to them (as usual), but an Object A can obtain a reference to an Object C only in one of the following 3 ways:\r\n\r\n1) By creation [A creates C]\r\n2) By construction [during construction of A it is endowed with a reference to C]\r\n3) By introduction [An object B to whom A has a reference introduces C to A]\r\n\r\nMore on this topic here: http://www.youtube.com/watch?v=zKuFu19LgZA _(around 42:00)_\r\n\r\nMoving on: from objects to methods. Even if we (as Object C) have been introduced to A, we don't want A to be able to mess with our internal state: hence, we start using private attributes and methods.\r\nIf we were to use prototypal inheritance, we could create C Objects using a factory-like method like the following one:\r\n\r\n```javascript\r\nfunction Object_C(...args){\r\n    var privateAttribute;\r\n    function privateMethod(){\r\n        ...\r\n    }\r\n    prototype = {\r\n        publicAttribute: someValue,\r\n        publicMethod: function(){\r\n            ...\r\n        }\r\n    }\r\n    var new_Object_C = Object.create(prototype);\r\n    return new_Object_C;\r\n}\r\n```\r\n\r\nSo far so good, right?\r\nBut what if we want to extend Object_C, creating a new \"class\" D, possibly overriding some of its public methods, while maintaining access to its protected ones? What if we need to override such methods and yet keep using their super version inside the new ones? And finally, what if we want A to be using either C and D objects without noticing the difference?\r\n\r\nOf course, we could achieve all of this by writing a separate factory for D, maintaining the same external interface as C while rewriting all its methods altogether.\r\nIt is possible, but - _let's face it_ - **it would be a mess**, and it wouldn't be much of a DRY implementation: if we play it smart we could reuse C public methods in D, but even so any change to C private methods would imply that the same change has to be copied to D ones.\r\nWhile it might be harsh but possible for a short inheritance tree and if the same developer is taking care of both \"classes\", if the inheritance tree contains dozens of classes, or more than one people have been working on them over time, well, here there is your recipe for bugs!\r\nOver time, you will most likely have a bunch of objects out of synch, until they fail spectacularly, obviously during a presentation in front of your clients (remember: software is a bitch, and JS software is the most bitchy of them all!)\r\n\r\nSo, let's see how you could get out of this mess.\r\nI propose a simple pattern, built upon one of the most famous design patterns, together with some extra care and good practices taken from other languages.\r\n\r\nWhat if we could wrap any object we want to introduce to the external mashup world inside a proxy that masks all the protected stuff from outside our trust circle, and handle only this wrapper to 3rd parties?\r\nThis way we could use public properties inside our libraries, fine-tuning all the writable, enumerable and configurable properties according to our inheritance needs, while hiding these objects altogether from whoever loads our libs;\r\nwe then expose an interface to the world that lets others creates these objects only through it, and by doing so handing over only the proxy wrappers to the consumers.\r\nSo, the only question is: how do we tell this proxy which properties should be exposed to the external world and which should be \"protected\"?\r\nThe answer is: there is no easy way using JavaScript, there is no such a construct, of course, otherwise we wouldn't be messing around with proxies and stuff, right?\r\nBut, thanks to ECMAscript 5, we might have a loophole: enumerable properties! We could create a proxy that will expose only the public functions we declare in our objects, if we agree to consider a method public if and only if it is an enumerable property of its owner. We can then make all protected methods not enumerable (and probably not writable as well, but that's another story), and so we can build an automated way to systematically add to the proxy a... proxy method linking to each one of the public methods in our objects.\r\n\r\n    **EDIT** Over the web you can find some good libraries that uses a similar idea but relies on naming conventions only: the risk is to move the concern from behaviour to aestetic, and might trick you if you use 3rd-party libs that uses a different naming convention. I think we can do better using ECMAScript 5 new features.\r\n    To make things a little bit clearer, I'd also suggest to have protected methods' names starting with __ (two underscores) in addition to declarying them non enumerable. But just _be aware that this naming convention isn't your main concern *(enumerability is)*_, and it's just for sake of clarity.\r\n\r\n\r\nBasically, all we need is adding a single method to the Object class:\r\n\r\n```javascript\r\n    /** createSafeProxy()\r\n    \r\n        Creates and returns a safe proxy for the object passed\r\n        that will wrap around it and expose only those methods\r\n        that are declared as enumerable.\r\n        \r\n        @param {boolean, default=false} CanDestroy \r\n                         States if the proxy consumer has the authority to call destroy \r\n                         on the original object\r\n        \r\n        @return {Object} A proxy wrapping this object;\r\n        @throw  Any exception the original object pseudo-constructor might throw.\r\n      */\r\n    function createSafeProxy(canDestroy){\r\n        \r\n        var property;\r\n        var proxy = Object.create(null);\r\n        var obj = this; //We must retain the \"this\" pointer to \r\n                        //the current object to use it inside different contexts\r\n        \r\n        for (property in obj){\r\n            //DO NOT check hasOwnProperty: the proxy must work for obj's prototype methods as well\r\n            //ONLY enumerable methods will be added to proxy's interface\r\n            if (Function.isFunction(obj[property])){\r\n                \r\n                //If it's a method not marked as protected, it is added to the proxy interface;\r\n                proxy[property] = ( \r\n                    function(p){\r\n                        return  function(){\r\n                                    var result;\r\n                                    if (obj){\r\n                                        result = obj[p].apply(obj, \r\n                                                    Array.prototype.slice.apply(arguments, [0]));\r\n                                        //Special care is needed to support method chaining\r\n                                        if (result === obj){\r\n                                            //obj.property returns obj itself,\r\n                                            //but we must return this proxy instead;\r\n                                            return proxy;\r\n                                        }else{\r\n                                            return result;\r\n                                        }\r\n                                    }else{\r\n                                        throw \"Null reference: the object has been already destroyed\";\r\n                                    }\r\n                                };\r\n                    })(property);\r\n            }\r\n        }\r\n        \r\n        //Adds a wrapping destroy method to allow withdrawal of the privileges \r\n        //given up introducing  the consumer to obj;\r\n        proxy.destroy = function(){\r\n                            try{\r\n                                if (canDestroy){\r\n                                    obj.destroy();  //Destroys the original object \r\n                                }                   //but only if authorized to\r\n                            }finally{\r\n                                obj = null;\r\n                            }\r\n                        };\r\n                            \r\n        return proxy;\r\n    }\r\n\r\n    if (!Object.prototype.createSafeProxy){\r\n        Object.defineProperty(Object.prototype, \"createSafeProxy\", {\r\n                                value: createSafeProxy,\r\n                                writable: false,\r\n                                enumerable: false,\r\n                                configurable: false\r\n                            });\r\n    }    \r\n```\r\n\r\nOne more thing we need to stress out: in order to have inheritance properly working, we need to handle original objects to the ones that are inheriting from them, but to avoid any possible encapsulation violation, the consumer should be able to access only their wrapped-in-proxy versions.\r\nWe therefore need to decouple this two aspects, and the perfect way to do so is through a factory. The factory will have internal private (pseudo)constructors for all our objects, and will expose only methods that creates a new object by returning its proxified version.\r\n\r\nHow cool is that, right? But, you know, everything comes with a price, and this time the price is that you can't have any public attribute in your classes. Is that bad? Well, not really: you just need to define the appropriate getters and setters methods for this attributes, being careful to declare them as public methods, and you're good to go! Even better, this forces you to abide with the strongest version of encapsulation best practice: no attribute should be public, but should only be accessed trough getters and setters - call it Ruby style, if you prefer.\r\n\r\nLet's see a full example, to (hopefully!) help clarifying a bit.\r\nFirst we can add a shortcut to \"Object\" object to help with the creation of public and protected methods (please take a look at it in the source code here: https://github.com/mlarocca/); it's also good to have a few more utility functions, like one to get super version of an overridden method.\r\nWith those tools in our belt, here is what we could obtain:        \r\n\r\n```javascript\r\nvar Factory = (\r\n    function(){\r\n        /** Object of type A\r\n            @private\r\n            \r\n            Private (to Factory) pseudo-constructor for A-type objects\r\n            */\r\n        function Object_A(arg1, arg2){\r\n            var obj_A = Object.create(Object);    //The new Object that will be returned\r\n            \r\n                //Private attribute: it will be visible to Object_A only\r\n            var privateAttribute1;\r\n                //Protected attribute: it will be visible to Object_A \r\n                //and every Object directly inheriting from it\r\n            obj_A.protectedAttribute1 = \"A\";  //[\"A\" is a placeholder for any value you might want]\r\n                \r\n                //Public attribute: it will also be visible to Object_A \r\n                //and every Object directly inheriting from it...\r\n            obj_A.publicAttribute1 = 1;  //[1 is a placeholder for any value you might want]\r\n            \r\n            //...but by defining a proper getter and setter, consumers will be able to modify it                        \r\n            obj_A.addPublicMethod(\"setPublicAttribute1\", \r\n                                    function(val){\r\n                                        //Special care is needed to ensure inheritance-compliancy\r\n                                        if (this.hasOwnProperty(\"publicAttribute1\")){\r\n                                            this.publicAttribute1 = val;\r\n                                        }else{\r\n                                            //If publicAttribute1 is inherited, \r\n                                            //we must look up for it in the super classes;\r\n                                            this.superMethod(\"setPublicAttribute1\", val);\r\n                                        }\r\n                                        return this;\r\n                                    });\r\n            obj_A.addPublicMethod(\"getPublicAttribute1\", function(){return this.publicAttribute1;});\r\n            \r\n            obj_A.publicMethod1 = function(m_arg1){\r\n                try{\r\n                    console.log(\"Obj \" + this.protectedAttribute1 + \": \" + arg1 + \", \" + arg2 + \";\", \"Method 1: \" + m_arg1);\r\n                }catch(err){\r\n                }\r\n            }\r\n\r\n            obj_A.addProtectedMethod(\"protectedMethod1\", function(){\r\n                //Protected method: you won't be able to call it through a proxy!\r\n                try{\r\n                    console.log(\"Protected Method 1\");\r\n                }catch(err){\r\n                }\r\n             });\r\n            \r\n            Object.seal(obj_A);   //You might want to do so, otherwise there is no real encapsulation\r\n                                  //WARNING: using freeze instead of seal would prevent any assignment\r\n                                  //objects's public attributes\r\n            \r\n            return obj_A;\r\n        }\r\n        \r\n        /**\r\n            Private (to Factory) pseudo-constructor for B-type objects\r\n            */\r\n        function Object_B(arg1, arg2, arg3){\r\n            var superObj = Object_A(arg1, arg2);    //The new Object that will be returned\r\n            var obj_B = Object.create(superObj);\r\n            \r\n                //Private attribute: it will be visible to Object_B only\r\n            var privateAttribute1;\r\n                //Protected attribute: it will be visible to Object_A and every Object directly inheriting from it\r\n                //Overrides obj_A.protectedAttribute1\r\n            obj_B.protectedAttribute1 = \"B\";  //[\"B\" is a placeholder for any value you might want]\r\n                \r\n            //Public attribute 1, together with its getters and setters, is inherited from : it will also be visible to Object_A and every Object directly inheriting from it...\r\n\r\n            \r\n            obj_B.publicMethod2 = function(m_arg1){\r\n                //Call protected method 1, just to show it can; \r\n                obj_B.protectedMethod1();\r\n            }\r\n            \r\n            Object.seal(obj_B);   //You might want to do so, otherwise there is no real encapsulation\r\n                                  //WARNING: using freeze instead of seal would prevent any assignment\r\n                                  //objects's public attributes\r\n            \r\n            return obj_B;\r\n        }                    \r\n        \r\n        var FactoryObj = {\r\n            Object_A: function(){\r\n                        return Object_A.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy();\r\n                      },\r\n            Object_B: function(){\r\n                        return Object_B.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy();\r\n                      }                                  \r\n        };\r\n        \r\n        Object.freeze(FactoryObj);  //We don't want anybody messing with our factory!\r\n        \r\n        return FactoryObj;\r\n    })();\r\n```\r\n\r\nAnd... that's about it!\r\nPlease feel free to drop a line if you have suggestions or you spotted a bug!"}