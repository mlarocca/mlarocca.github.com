<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Mlarocca.github.com by mlarocca</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Mlarocca.github.com</h1>
        <p>MLR Blog</p>


        <p class="view"><a href="https://github.com/mlarocca">View My GitHub Profile</a></p>

      </header>
      <section>
        <h2>** Combining effective encapsulation and inheritance in JavaScript**</h2>

<p>While developing a plugin for the D3 graphic library, I found myself facing one of the most common conundrum for a JavaScript programmer: how on Earth is it possible to get a good compromise between encapsulation and extensibility?</p>

<p>Don't get me wrong, there are many different known techniques to safely and effectively keep private attributes and methods really private (mostly involving closure and local vars), as well as there are many more to mimic inheritance, from pseudo-classical to prototypal or parasitic ones.
A very good source of inspiration for all of these techniques can be found on <em>Douglas Crockford</em> web sites or, if you have a little bit more time, in some of his great videos on <em>YUITheather</em> (a must for any JS developer).</p>

<p>But as far as I know there have been only a few attempts to cope with both problems at the same time: there is no "protected" encapsulation in JavaScript, and none of them looks particularly easy or satisfying to me.
And that's a bummer, I mean, web development today is all about mash-ups, and every JS engineer  at some point will have to exploit mash-ups, so she will be (well, at least he really SHOULD BE) necessarily concerned about the methods that his objects are going to expose to consumers.</p>

<p>The most common solution starts, or at least it should, from embracing an Object Capability System.
In such a paradigm, Objects can communicate with other objects only if they have a reference to them (as usual), but an Object A can obtain a reference to an Object C only in one of the following 3 ways:</p>

<p>1) By creation [A creates C]
2) By construction [during construction of A it is endowed with a reference to C]
3) By introduction [An object B to whom A has a reference introduces C to A]</p>

<p>More on this topic here: <a href="http://www.youtube.com/watch?v=zKuFu19LgZA">http://www.youtube.com/watch?v=zKuFu19LgZA</a> <em>(around 42:00)</em></p>

<p>Moving on: from objects to methods. Even if we (as Object C) have been introduced to A, we don't want A to be able to mess with our internal state: hence, we start using private attributes and methods.
If we were to use prototypal inheritance, we could create C Objects using a factory-like method like the following one:</p>

<div class="highlight"><pre><span class="kd">function</span> <span class="nx">Object_C</span><span class="p">(...</span><span class="nx">args</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">privateAttribute</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">privateMethod</span><span class="p">(){</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">publicAttribute</span><span class="o">:</span> <span class="nx">someValue</span><span class="p">,</span>
        <span class="nx">publicMethod</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">new_Object_C</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">prototype</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">new_Object_C</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>So far so good, right?
But what if we want to extend Object_C, creating a new "class" D, possibly overriding some of its public methods, while maintaining access to its protected ones? What if we need to override such methods and yet keep using their super version inside the new ones? And finally, what if we want A to be using either C and D objects without noticing the difference?</p>

<p>Of course, we could achieve all of this by writing a separate factory for D, maintaining the same external interface as C while rewriting all its methods altogether.
It is possible, but - <em>let's face it</em> - <strong>it would be a mess</strong>, and it wouldn't be much of a DRY implementation: if we play it smart we could reuse C public methods in D, but even so any change to C private methods would imply that the same change has to be copied to D ones.
While it might be harsh but possible for a short inheritance tree and if the same developer is taking care of both "classes", if the inheritance tree contains dozens of classes, or more than one people have been working on them over time, well, here there is your recipe for bugs!
Over time, you will most likely have a bunch of objects out of synch, until they fail spectacularly, obviously during a presentation in front of your clients (remember: software is a bitch, and JS software is the most bitchy of them all!)</p>

<p>So, let's see how you could get out of this mess.
I propose a simple pattern, built upon one of the most famous design patterns, together with some extra care and good practices taken from other languages.</p>

<p>What if we could wrap any object we want to introduce to the external mashup world inside a proxy that masks all the protected stuff from outside our trust circle, and handle only this wrapper to 3rd parties?
This way we could use public properties inside our libraries, fine-tuning all the writable, enumerable and configurable properties according to our inheritance needs, while hiding these objects altogether from whoever loads our libs;
we then expose an interface to the world that lets others creates these objects only through it, and by doing so handing over only the proxy wrappers to the consumers.
So, the only question is: how do we tell this proxy which properties should be exposed to the external world and which should be "protected"?
The answer is: there is no easy way using JavaScript, there is no such a construct, of course, otherwise we wouldn't be messing around with proxies and stuff, right?
But, thanks to ECMAscript 5, we might have a loophole: enumerable properties! We could create a proxy that will expose only the public functions we declare in our objects, if we agree to consider a method public if and only if it is an enumerable property of its owner. We can then make all protected methods not enumerable (and probably not writable as well, but that's another story), and so we can build an automated way to systematically add to the proxy a... proxy method linking to each one of the public methods in our objects.</p>

<pre><code>**EDIT** Over the web you can find some good libraries that uses a similar idea but relies on naming conventions only: the risk is to move the concern from behaviour to aestetic, and might trick you if you use 3rd-party libs that uses a different naming convention. I think we can do better using ECMAScript 5 new features.
To make things a little bit clearer, I'd also suggest to have protected methods' names starting with __ (two underscores) in addition to declarying them non enumerable. But just _be aware that this naming convention isn't your main concern *(enumerability is)*_, and it's just for sake of clarity.
</code></pre>

<p>Basically, all we need is adding a single method to the Object class:</p>

<div class="highlight"><pre>    <span class="cm">/** createSafeProxy()</span>

<span class="cm">        Creates and returns a safe proxy for the object passed</span>
<span class="cm">        that will wrap around it and expose only those methods</span>
<span class="cm">        that are declared as enumerable.</span>

<span class="cm">        @param {boolean, default=false} CanDestroy </span>
<span class="cm">                         States if the proxy consumer has the authority to call destroy </span>
<span class="cm">                         on the original object</span>

<span class="cm">        @return {Object} A proxy wrapping this object;</span>
<span class="cm">        @throw  Any exception the original object pseudo-constructor might throw.</span>
<span class="cm">      */</span>
    <span class="kd">function</span> <span class="nx">createSafeProxy</span><span class="p">(</span><span class="nx">canDestroy</span><span class="p">){</span>

        <span class="kd">var</span> <span class="nx">property</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">//We must retain the "this" pointer to </span>
                        <span class="c1">//the current object to use it inside different contexts</span>

        <span class="k">for</span> <span class="p">(</span><span class="nx">property</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">){</span>
            <span class="c1">//DO NOT check hasOwnProperty: the proxy must work for obj's prototype methods as well</span>
            <span class="c1">//ONLY enumerable methods will be added to proxy's interface</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">Function</span><span class="p">.</span><span class="nx">isFunction</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">property</span><span class="p">])){</span>

                <span class="c1">//If it's a method not marked as protected, it is added to the proxy interface;</span>
                <span class="nx">proxy</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> 
                    <span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">){</span>
                        <span class="k">return</span>  <span class="kd">function</span><span class="p">(){</span>
                                    <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
                                    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
                                        <span class="nx">result</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">p</span><span class="p">].</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> 
                                                    <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
                                        <span class="c1">//Special care is needed to support method chaining</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">===</span> <span class="nx">obj</span><span class="p">){</span>
                                            <span class="c1">//obj.property returns obj itself,</span>
                                            <span class="c1">//but we must return this proxy instead;</span>
                                            <span class="k">return</span> <span class="nx">proxy</span><span class="p">;</span>
                                        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                                            <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
                                        <span class="p">}</span>
                                    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                                        <span class="k">throw</span> <span class="s2">"Null reference: the object has been already destroyed"</span><span class="p">;</span>
                                    <span class="p">}</span>
                                <span class="p">};</span>
                    <span class="p">})(</span><span class="nx">property</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//Adds a wrapping destroy method to allow withdrawal of the privileges </span>
        <span class="c1">//given up introducing  the consumer to obj;</span>
        <span class="nx">proxy</span><span class="p">.</span><span class="nx">destroy</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
                            <span class="k">try</span><span class="p">{</span>
                                <span class="k">if</span> <span class="p">(</span><span class="nx">canDestroy</span><span class="p">){</span>
                                    <span class="nx">obj</span><span class="p">.</span><span class="nx">destroy</span><span class="p">();</span>  <span class="c1">//Destroys the original object </span>
                                <span class="p">}</span>                   <span class="c1">//but only if authorized to</span>
                            <span class="p">}</span><span class="k">finally</span><span class="p">{</span>
                                <span class="nx">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">};</span>

        <span class="k">return</span> <span class="nx">proxy</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">createSafeProxy</span><span class="p">){</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">"createSafeProxy"</span><span class="p">,</span> <span class="p">{</span>
                                <span class="nx">value</span><span class="o">:</span> <span class="nx">createSafeProxy</span><span class="p">,</span>
                                <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                                <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
                                <span class="nx">configurable</span><span class="o">:</span> <span class="kc">false</span>
                            <span class="p">});</span>
    <span class="p">}</span>    
</pre></div>

<p>One more thing we need to stress out: in order to have inheritance properly working, we need to handle original objects to the ones that are inheriting from them, but to avoid any possible encapsulation violation, the consumer should be able to access only their wrapped-in-proxy versions.
We therefore need to decouple this two aspects, and the perfect way to do so is through a factory. The factory will have internal private (pseudo)constructors for all our objects, and will expose only methods that creates a new object by returning its proxified version.</p>

<p>How cool is that, right? But, you know, everything comes with a price, and this time the price is that you can't have any public attribute in your classes. Is that bad? Well, not really: you just need to define the appropriate getters and setters methods for this attributes, being careful to declare them as public methods, and you're good to go! Even better, this forces you to abide with the strongest version of encapsulation best practice: no attribute should be public, but should only be accessed trough getters and setters - call it Ruby style, if you prefer.</p>

<p>Let's see a full example, to (hopefully!) help clarifying a bit.
First we can add a shortcut to "Object" object to help with the creation of public and protected methods (please take a look at it in the source code here: <a href="https://github.com/mlarocca/">https://github.com/mlarocca/</a>); it's also good to have a few more utility functions, like one to get super version of an overridden method.
With those tools in our belt, here is what we could obtain:        </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Factory</span> <span class="o">=</span> <span class="p">(</span>
    <span class="kd">function</span><span class="p">(){</span>
        <span class="cm">/** Object of type A</span>
<span class="cm">            @private</span>

<span class="cm">            Private (to Factory) pseudo-constructor for A-type objects</span>
<span class="cm">            */</span>
        <span class="kd">function</span> <span class="nx">Object_A</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">obj_A</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">);</span>    <span class="c1">//The new Object that will be returned</span>

                <span class="c1">//Private attribute: it will be visible to Object_A only</span>
            <span class="kd">var</span> <span class="nx">privateAttribute1</span><span class="p">;</span>
                <span class="c1">//Protected attribute: it will be visible to Object_A </span>
                <span class="c1">//and every Object directly inheriting from it</span>
            <span class="nx">obj_A</span><span class="p">.</span><span class="nx">protectedAttribute1</span> <span class="o">=</span> <span class="s2">"A"</span><span class="p">;</span>  <span class="c1">//["A" is a placeholder for any value you might want]</span>

                <span class="c1">//Public attribute: it will also be visible to Object_A </span>
                <span class="c1">//and every Object directly inheriting from it...</span>
            <span class="nx">obj_A</span><span class="p">.</span><span class="nx">publicAttribute1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">//[1 is a placeholder for any value you might want]</span>

            <span class="c1">//...but by defining a proper getter and setter, consumers will be able to modify it                        </span>
            <span class="nx">obj_A</span><span class="p">.</span><span class="nx">addPublicMethod</span><span class="p">(</span><span class="s2">"setPublicAttribute1"</span><span class="p">,</span> 
                                    <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>
                                        <span class="c1">//Special care is needed to ensure inheritance-compliancy</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s2">"publicAttribute1"</span><span class="p">)){</span>
                                            <span class="k">this</span><span class="p">.</span><span class="nx">publicAttribute1</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
                                        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                                            <span class="c1">//If publicAttribute1 is inherited, </span>
                                            <span class="c1">//we must look up for it in the super classes;</span>
                                            <span class="k">this</span><span class="p">.</span><span class="nx">superMethod</span><span class="p">(</span><span class="s2">"setPublicAttribute1"</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span>
                                        <span class="p">}</span>
                                        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
                                    <span class="p">});</span>
            <span class="nx">obj_A</span><span class="p">.</span><span class="nx">addPublicMethod</span><span class="p">(</span><span class="s2">"getPublicAttribute1"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">publicAttribute1</span><span class="p">;});</span>

            <span class="nx">obj_A</span><span class="p">.</span><span class="nx">publicMethod1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">m_arg1</span><span class="p">){</span>
                <span class="k">try</span><span class="p">{</span>
                    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Obj "</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">protectedAttribute1</span> <span class="o">+</span> <span class="s2">": "</span> <span class="o">+</span> <span class="nx">arg1</span> <span class="o">+</span> <span class="s2">", "</span> <span class="o">+</span> <span class="nx">arg2</span> <span class="o">+</span> <span class="s2">";"</span><span class="p">,</span> <span class="s2">"Method 1: "</span> <span class="o">+</span> <span class="nx">m_arg1</span><span class="p">);</span>
                <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nx">obj_A</span><span class="p">.</span><span class="nx">addProtectedMethod</span><span class="p">(</span><span class="s2">"protectedMethod1"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
                <span class="c1">//Protected method: you won't be able to call it through a proxy!</span>
                <span class="k">try</span><span class="p">{</span>
                    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Protected Method 1"</span><span class="p">);</span>
                <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
                <span class="p">}</span>
             <span class="p">});</span>

            <span class="nb">Object</span><span class="p">.</span><span class="nx">seal</span><span class="p">(</span><span class="nx">obj_A</span><span class="p">);</span>   <span class="c1">//You might want to do so, otherwise there is no real encapsulation</span>
                                  <span class="c1">//WARNING: using freeze instead of seal would prevent any assignment</span>
                                  <span class="c1">//objects's public attributes</span>

            <span class="k">return</span> <span class="nx">obj_A</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/**</span>
<span class="cm">            Private (to Factory) pseudo-constructor for B-type objects</span>
<span class="cm">            */</span>
        <span class="kd">function</span> <span class="nx">Object_B</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,</span> <span class="nx">arg3</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">superObj</span> <span class="o">=</span> <span class="nx">Object_A</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">);</span>    <span class="c1">//The new Object that will be returned</span>
            <span class="kd">var</span> <span class="nx">obj_B</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">superObj</span><span class="p">);</span>

                <span class="c1">//Private attribute: it will be visible to Object_B only</span>
            <span class="kd">var</span> <span class="nx">privateAttribute1</span><span class="p">;</span>
                <span class="c1">//Protected attribute: it will be visible to Object_A and every Object directly inheriting from it</span>
                <span class="c1">//Overrides obj_A.protectedAttribute1</span>
            <span class="nx">obj_B</span><span class="p">.</span><span class="nx">protectedAttribute1</span> <span class="o">=</span> <span class="s2">"B"</span><span class="p">;</span>  <span class="c1">//["B" is a placeholder for any value you might want]</span>

            <span class="c1">//Public attribute 1, together with its getters and setters, is inherited from : it will also be visible to Object_A and every Object directly inheriting from it...</span>


            <span class="nx">obj_B</span><span class="p">.</span><span class="nx">publicMethod2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">m_arg1</span><span class="p">){</span>
                <span class="c1">//Call protected method 1, just to show it can; </span>
                <span class="nx">obj_B</span><span class="p">.</span><span class="nx">protectedMethod1</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="nb">Object</span><span class="p">.</span><span class="nx">seal</span><span class="p">(</span><span class="nx">obj_B</span><span class="p">);</span>   <span class="c1">//You might want to do so, otherwise there is no real encapsulation</span>
                                  <span class="c1">//WARNING: using freeze instead of seal would prevent any assignment</span>
                                  <span class="c1">//objects's public attributes</span>

            <span class="k">return</span> <span class="nx">obj_B</span><span class="p">;</span>
        <span class="p">}</span>                    

        <span class="kd">var</span> <span class="nx">FactoryObj</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">Object_A</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
                        <span class="k">return</span> <span class="nx">Object_A</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])).</span><span class="nx">createSafeProxy</span><span class="p">();</span>
                      <span class="p">},</span>
            <span class="nx">Object_B</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
                        <span class="k">return</span> <span class="nx">Object_B</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])).</span><span class="nx">createSafeProxy</span><span class="p">();</span>
                      <span class="p">}</span>                                  
        <span class="p">};</span>

        <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">(</span><span class="nx">FactoryObj</span><span class="p">);</span>  <span class="c1">//We don't want anybody messing with our factory!</span>

        <span class="k">return</span> <span class="nx">FactoryObj</span><span class="p">;</span>
    <span class="p">})();</span>
</pre></div>

<p>And... that's about it!
Please feel free to drop a line if you have suggestions or you spotted a bug!</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-37178706-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>