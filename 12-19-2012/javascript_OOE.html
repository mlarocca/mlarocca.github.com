<h1>Combining effective encapsulation and inheritance in JavaScript</h1>

<p>While developing a plugin for the D3 graphic library, I found myself facing one of the most common conundrum for a JavaScript programmer: how on Earth is it possible to get a good compromise between encapsulation and extensibility?</p>

<p>Don&#39;t get me wrong, there are many different known techniques to safely and effectively keep private attributes and methods really private (mostly involving closure and local vars), as well as there are many more to mimic inheritance, from pseudo-classical to prototypal or parasitic ones.
A very good source of inspiration for all of these techniques can be found on <em>Douglas Crockford</em> web sites or, if you have a little bit more time, in some of his great videos on <em>YUITheather</em> (a must for any JS developer).</p>

<p>But as far as I know there have been only a few attempts to cope with both problems at the same time: there is no &quot;protected&quot; encapsulation in JavaScript, and none of them looks particularly easy or satisfying to me.
And that&#39;s a bummer, I mean, web development today is all about mash-ups, and every JS engineer  at some point will have to exploit mash-ups, so she will be (well, at least he really SHOULD BE) necessarily concerned about the methods that his objects are going to expose to consumers.</p>

<p>The most common solution starts, or at least it should, from embracing an Object Capability System.
In such a paradigm, Objects can communicate with other objects only if they have a reference to them (as usual), but an Object A can obtain a reference to an Object C only in one of the following 3 ways:</p>

<ol>
<li>By creation (A creates C)</li>
<li>By construction (during construction of A it is endowed with a reference to C)</li>
<li>By introduction (An object B to whom A has a reference introduces C to A)</li>
</ol>

<p>More on this topic here: http://www.youtube.com/watch?v=zKuFu19LgZA <em>(around 42:00)</em></p>

<p>Moving on: from objects to methods. Even if we (as Object C) have been introduced to A, we don&#39;t want A to be able to mess with our internal state: hence, we start using private attributes and methods.
If we were to use prototypal inheritance, we could create C Objects using a factory-like method like the following one:</p>
<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">Object_C</span><span class="p">(...</span><span class="nx">args</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">privateAttribute</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">privateMethod</span><span class="p">(){</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">publicAttribute</span><span class="o">:</span> <span class="nx">someValue</span><span class="p">,</span>
        <span class="nx">publicMethod</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">new_Object_C</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">prototype</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">new_Object_C</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>So far so good, right?
But what if we want to extend Object_C, creating a new &quot;class&quot; D, possibly overriding some of its public methods, while maintaining access to its protected ones? What if we need to override such methods and yet keep using their super version inside the new ones? And finally, what if we want A to be using either C and D objects without noticing the difference?</p>

<p>Of course, we could achieve all of this by writing a separate factory for D, maintaining the same external interface as C while rewriting all its methods altogether.
It is possible, but - <em>let&#39;s face it</em> - <strong>it would be a mess</strong>, and it wouldn&#39;t be much of a DRY implementation: if we play it smart we could reuse C public methods in D, but even so any change to C private methods would imply that the same change has to be copied to D ones.
While it might be harsh but possible for a short inheritance tree and if the same developer is taking care of both &quot;classes&quot;, if the inheritance tree contains dozens of classes, or more than one people have been working on them over time, well, here there is your recipe for bugs!
Over time, you will most likely have a bunch of objects out of synch, until they fail spectacularly, obviously during a presentation in front of your clients (remember: software is a bitch, and JS software is the most bitchy of them all!)</p>

<p>So, let&#39;s see how you could get out of this mess.
I propose a simple pattern, built upon one of the most famous design patterns, together with some extra care and good practices taken from other languages.</p>

<p>What if we could wrap any object we want to introduce to the external mashup world inside a proxy that masks all the protected stuff from outside our trust circle, and handle only this wrapper to 3rd parties?
This way we could use public properties inside our libraries, fine-tuning all the writable, enumerable and configurable properties according to our inheritance needs, while hiding these objects altogether from whoever loads our libs;
we then expose an interface to the world that lets others creates these objects only through it, and by doing so handing over only the proxy wrappers to the consumers.
So, the only question is: how do we tell this proxy which properties should be exposed to the external world and which should be &quot;protected&quot;?
The answer is: there is no easy way using JavaScript, there is no such a construct, of course, otherwise we wouldn&#39;t be messing around with proxies and stuff, right?
But, thanks to ECMAscript 5, we might have a loophole: enumerable properties! We could create a proxy that will expose only the public functions we declare in our objects, if we agree to consider a method public if and only if it is an enumerable property of its owner. We can then make all protected methods not enumerable (and probably not writable as well, but that&#39;s another story), and so we can build an automated way to systematically add to the proxy a... proxy method linking to each one of the public methods in our objects.</p>

<p><strong>EDIT</strong> Over the web you can find some good libraries that uses a similar idea but relies on naming conventions only: the risk is to move the concern from behaviour to aestetic, and might trick you if you use 3rd-party libs that uses a different naming convention. I think we can do better using ECMAScript 5 new features.
    To make things a little bit clearer, I&#39;d also suggest to have protected methods&#39; names starting with __ (two underscores) in addition to declarying them non enumerable. But just <em>be aware that this naming convention isn&#39;t your main concern <em>(enumerability is)</em></em>, and it&#39;s just for sake of clarity.</p>
